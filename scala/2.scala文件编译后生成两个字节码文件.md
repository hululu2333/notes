## scala文件编译后生成两个字节码文件

> 一般情况下，一个.java文件编译后只生成一个.class文件（没有内部类的情况下）。而一般情况下一个.scala文件编译后会生成两个.class文件。下面我们用将scala字节码反编译为java代码的方式来解释。
>
> **（反编译器反编译时可能会产生一些语法错误，只要不影响我们理解代码就行）**



### scala代码

>HelloWorld.scala中有如下代码，object是伴生对象，class是伴生类，编译后生成HelloWorld.class和HelloWorld$.class。 当然，一个scala文件中可以只有object或者class，如果只有class，则编译后只有一个.calss文件。不然只要有object就会有两个class文件。

![image-20210627195506584](F:\学习笔记\scala\imgs\scala代码.png)

### 反编译后的java代码

> HelloWorld.class文件是程序的入口，可以把它与伴生类对应。（打马赛克的地方可以忽略，这块代码没用）伴生类中定义了一个属性，而反编译后有一个私有属性和一个公有的调用这个属性的方法。除此之外多了一个静态的main方法，用来调用HelloWorld$中的方法。
>
> 此处的HelloWorld.应该是HelloWorld$

![image-20210627200519149](F:\学习笔记\scala\imgs\伴生类对应的java代码.png)

***

> 可以看出，HelloWorld$是一个实现了单例模式的类。这个类只会有一个对象，且这个对象在这个类被加载的时候就已经定义好了。
>
> 所有伴生对象中定义的属性和方法都会在这个类中定义。也就是说，定义在伴生对象中的方法和属性，就和java中的静态方法和属性的含义一样，一个类中只有一份。java是存在方法区且不属于某个对象，而scala是存在一个单例对象中
>
> 在scala语法层面，我们也可以通过类名.方法名的方式来访问定义在伴生对象中的方法
>
> 符合面向对象应该是这个意思，定义在伴生类中的属性就是属于伴生类的对象的，定义在伴生对象中的属性就是属于伴生对象的对象的。而我们创建一个HelloWorld对象，默认就是创建了伴生类的对象，因为伴生对象实现了单例模式，所以我们可以通过类名.方法名的方式来访问定义在伴生对象中的方法

![image-20210627200550288](F:\学习笔记\scala\imgs\伴生对象对应的java代码.png)

