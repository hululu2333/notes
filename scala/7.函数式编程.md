## 函数式编程 

> 编程里有三大编程范式，面向对象、面向过程和函数式。函数式编程的思想来源于数学中的函数



### 函数与方法的区别

>定义函数和定义方法的语法是一样的，但为了区分，如果定义在类中我们就将其称为方法，定义在方法中，我们就称其为函数。（伴生类和伴生对象都是类，只不过伴生对象在底层是实现了单例模式的类）
>
>方法定义在类中，是属于这个类的对象的，需要对象去调用它。在同一个类中，一个方法可以直接调用另一个方法而不用采用对象名.方法名的方式，是因为方法名前省略了个this。
>
>函数定义在方法中，它只是一个完成了某个功能的代码块，可以直接调用



### 函数中形参的特性

> 因为函数与方法只是定义的位置不同，所以这些特性在方法中也适用

> **可变参数**，一个函数中只能有一个可变参数，并且要放在最后。如`def show(str : String*)={}`。String *本质上是一个数组，WrappedArray[String]。java中也有可变参数，如`main(String[] agrs)`

> **参数默认值：**我们可以给形参赋值，这样的话调用这个函数时可以不传入这个参数。如果不传就是用默认值，如果传了就用传入值。java中是不能这样操作的

``` scala
def show(str: String = "bighu"): Unit = {
    println(str)
}

show("small")
show()
```

***

> **传参时指定参数名：**这样的话可以不按照形参的定义顺序来传参，当形参中有的参数有默认值时，这样会很方便

``` scala
def show(name: String = "bighu",age:Int): Unit = {
    println(s"${age}岁的${name}")
}

show(age=5)
```



### 函数至简原则

> 一个较为完整的函数（或方法）定义如下

```scala
def show(name: String = "bighu",age:Int): String = {
	println(s"${age}岁的${name}")
	return name+age
}
```

> 但为了代码的简洁性，我们可以对其进行一些简化。简化规则如下。（以下用函数指代函数与方法）简化到极致就有点像数学中的函数了
>
> 但我认为，为了区分方法与函数，方法最好不要进行过多简化

``` scala
// return可以省略，scala会使用函数体的最后一行代码的返回值当作函数的返回值

// 如果函数体只有一行代码，花括号可以省略	def say():Unit = println("hello")

// 如果省略了return，并且函数返回值类型可以推断出来，那么返回值类型可以省略

// 如果我们不指定函数返回值类型，且不加”=“。那么这个函数的返回值类型会被推导为Unit，即使你函数体最后一行代码的返回值不为Unit也没用。这个函数只会返回()

// 我们定义函数的时候，如果没有形参，就可以不加小括号，如def say : Unit = {}。这样的话，当我们调用这个函数的时候就不能加小括号了。如果定义函数的时候加了小括号，则调用的时候可加可不加

// 匿名函数（lambda表达式），如果不关心函数名称，只关心逻辑处理，那么def 和函数名都可以省略，然后把”=“换成”=>“。 如：(name: String) => println(name)。方法不能这样干，我们定义方法必须要有方法名。
```

> **其实按我的理解，写一个匿名函数已经不是定义一个函数了，而是创建了一个函数类型的实例**



### 匿名函数

> 匿名函数就是lambda表达式，java中也引用了这个特性

#### 匿名函数的用法

``` scala
// 这定义了一个匿名函数，但是我们怎么才能去调用这个函数呢
(name: String) => {
    println(name)
}

// 我们可以定义一个常量来接住这个匿名函数，那这个常量的类型就是函数类型了。既然是函数类型，那fu这个常量可以看作是一个函数实例，对象是可以调用方法的，那fu这个实例只能调用他自身这个函数了
val fu = (name: String) => println(name)
fu("bighu")

// 根据scala的自动类型推导，我们可知fu的类型为"String => Unit"，那我们就知道"String => Unit"代表的是入参类型为String 返回值类型为Unit的函数类型
// "fu" 这行代码的返回值是函数类型，"fu()" 这行代码返回的就是Unit类型，这个因该容易理解
val fu: String => Unit = (name: String) => println(name)

// 既然scala的类型系统中有函数这个类型，那么一个函数的形参也可以是函数类型了吧
// 定义一个形参类型为 String => Unit 的函数，调用say函数时可以把fu这个函数实例传入
def say(fu: String => Unit) = {
    fu("ss")
}
say(fu)
```

> **匿名函数与其他函数的区别：我们用def 定义一个函数，无论简化到什么程度，那我们做的行为都是在定义一个函数，是一个定义语句！当我们搞了一个匿名函数，如(name: String) => println(name)，这时我们没有定义一个函数，而是创建了一个函数类型类型的实例，是创建语句！就和new一个对象一样**

***

#### 匿名函数的简化规则

> 当我们直接把一个匿名函数当作实参传入一个函数时，将匿名函数简化就很有必要了

``` scala
// 定义一个形参类型为 String => Unit的函数
def say(fu: String => Unit) = {
    fu("ss")
}


// 当我们把"(name: String) => println(name)"直接传入形参类型为String => Unit的函数时，匿名函数的参数类型可以省略
// 函数say的形参是fu，当我们把“(name) => println(name)”当作实参传入时，say中的fu的值就是“(name) => println(name)”
say((name) => println(name))

// 当匿名函数的参数类型可以省略，且匿名函数只有一个形参，那么包含形参的小括号也可以省略
say(name => println(name))

// 当匿名函数的函数体只有一行时，大括号可以省略，以上两个例子都符合

以下两行还不是很理解。怎样才能不止出现一次是什么情况，怎样才能不传入一个函数体而是调用语句当
// 如果参数只出现一次，则参数省略且后面参数可以用_代替
say(println(_))

// 如果可以推断出当前传入的println是一个函数体，而不是调用语句，可以直接省略下划线
say(println)

```

