## 函数式编程 

> 编程里有三大编程范式，面向对象、面向过程和函数式。函数式编程的思想来源于数学中的函数



### 函数与方法的区别

>定义函数和定义方法的语法是一样的，但为了区分，如果定义在类中我们就将其称为方法，定义在方法中，我们就称其为函数。（伴生类和伴生对象都是类，只不过伴生对象在底层是实现了单例模式的类）
>
>方法定义在类中，是属于这个类的对象的，需要对象去调用它。在同一个类中，一个方法可以直接调用另一个方法而不用采用对象名.方法名的方式，是因为方法名前省略了个this。
>
>函数定义在方法中，它只是一个完成了某个功能的代码块，可以直接调用



### 函数中形参的特性

> 因为函数与方法只是定义的位置不同，所以这些特性在方法中也适用

> **可变参数**，一个函数中只能有一个可变参数，并且要放在最后。如`def show(str : String*)={}`。String *本质上是一个数组，WrappedArray[String]。java中也有可变参数，如`main(String[] agrs)`

> **参数默认值：**我们可以给形参赋值，这样的话调用这个函数时可以不传入这个参数。如果不传就是用默认值，如果传了就用传入值。java中是不能这样操作的

``` scala
def show(str: String = "bighu"): Unit = {
    println(str)
}

show("small")
show()
```

***

> **传参时指定参数名：**这样的话可以不按照形参的定义顺序来传参，当形参中有的参数有默认值时，这样会很方便

``` scala
def show(name: String = "bighu",age:Int): Unit = {
    println(s"${age}岁的${name}")
}

show(age=5)
```



### 函数至简原则

> 一个较为完整的函数（或方法）定义如下

```scala
def show(name: String = "bighu",age:Int): String = {
	println(s"${age}岁的${name}")
	return name+age
}
```

> 但为了代码的简洁性，我们可以对其进行一些简化。简化规则如下。（以下用函数指代函数与方法）简化到极致就有点像数学中的函数了
>
> 但我认为，为了区分方法与函数，方法最好不要进行过多简化

``` scala
// return可以省略，scala会使用函数体的最后一行代码的返回值当作函数的返回值

// 如果函数体只有一行代码，花括号可以省略	def say():Unit = println("hello")

// 如果省略了return，并且函数返回值类型可以推断出来，那么返回值类型可以省略

// 如果我们不指定函数返回值类型，且不加”=“。那么这个函数的返回值类型会被推导为Unit，即使你函数体最后一行代码的返回值不为Unit也没用。这个函数只会返回()

// 我们定义函数的时候，如果没有形参，就可以不加小括号，如def say : Unit = {}。这样的话，当我们调用这个函数的时候就不能加小括号了。如果定义函数的时候加了小括号，则调用的时候可加可不加

// 匿名函数（lambda表达式），如果不关心函数名称，只关心逻辑处理，那么def 和函数名都可以省略，然后把”=“换成”=>“。 如：(name: String) => println(name)。方法不能这样干，我们定义方法必须要有方法名。
```

> **其实按我的理解，写一个匿名函数已经不是定义一个函数了，而是创建了一个函数类型的实例**



### 匿名函数

> 匿名函数就是lambda表达式，java中也引用了这个特性

#### 匿名函数的用法

``` scala
// 这定义了一个匿名函数，但是我们怎么才能去调用这个函数呢
(name: String) => {
    println(name)
}

// 我们可以定义一个常量来接住这个匿名函数，那这个常量的类型就是函数类型了。既然是函数类型，那fu这个常量可以看作是一个函数实例，对象是可以调用方法的，那fu这个实例只能调用他自身这个函数了
val fu = (name: String) => println(name)
fu("bighu")

// 根据scala的自动类型推导，我们可知fu的类型为"String => Unit"，那我们就知道"String => Unit"代表的是入参类型为String 返回值类型为Unit的函数类型
// "fu" 这行代码的返回值是函数类型，"fu()" 这行代码返回的就是Unit类型，这个因该容易理解
val fu: String => Unit = (name: String) => println(name)

// 既然scala的类型系统中有函数这个类型，那么一个函数的形参也可以是函数类型了吧
// 定义一个形参类型为 String => Unit 的函数，调用say函数时可以把fu这个函数实例传入
def say(fu: String => Unit) = {
    fu("ss")
}
say(fu)
```

> **匿名函数与其他函数的区别：我们用def 定义一个函数，无论简化到什么程度，那我们做的行为都是在定义一个函数，是一个定义语句！当我们搞了一个匿名函数，如(name: String) => println(name)，这时我们没有定义一个函数，而是创建了一个函数类型类型的实例，是创建语句！就和new一个对象一样**

***

#### 匿名函数的简化规则

> 当我们直接把一个匿名函数当作实参传入一个函数时，将匿名函数简化就很有必要了

``` scala
// 定义一个形参类型为 String => Unit的函数
def say(fu: String => Unit) = {
    fu("ss")
}


// 当我们把"(name: String) => println(name)"直接传入形参类型为String => Unit的函数时，匿名函数的参数类型可以省略
// 函数say的形参是fu，当我们把“(name) => println(name)”当作实参传入时，say中的fu的值就是“(name) => println(name)”
say((name) => println(name))

// 当匿名函数的参数类型可以省略，且匿名函数只有一个形参，那么包含形参的小括号也可以省略
say(name => println(name))

// 当匿名函数的函数体只有一行时，大括号可以省略，以上两个例子都符合

// 当匿名函数的函数体只有一行，且匿名函数的形参在函数体中只出现一次，则参数和=>省略且函数体里的参数可以用_代替
say(name => println(name))  简化为  say(println(_))
// 这个简化有点复杂，在某种情况下会简化失败，并且我无法解释。尽量先写完整的，然后一步步简化吧

// 如果可以推断出当前传入的println是一个函数体，而不是调用语句，可以直接省略下划线
say(println)
```



### 高阶函数

> 高阶函数指的是函数的一些高级特性，例如利用所定义的函数来创建一个函数实例，函数实例可以作为实参传入另一个函数，函数实例可以作为函数的返回值进行返回

#### 利用定义的函数创建函数实例

> 我们之前已经分析过了，定义一个函数是一个定义语句，就像用class定义一个类一样。写一个匿名函数是创建了一个函数类型的实例，就像new了一个类的对象一样
>
> 既然如此，那我们能不能用已经定义了的函数来创建一个对应的函数类型的实例，答案是可以的。创建方法如下

``` scala
// 定义一个函数
def say(str : String) = {
    println(str)
}

// 创建该函数类型的实例，可以把say _理解为new 一个Function类的对象
val f1 = say _

// 当我们指定了常量的数据类型就是函数类型，就不用在函数名后加下划线了
val f2 String => Unit = say

```

***

#### 函数实例可以作为实参传入另一个函数

> 这个特性在我们讨论匿名函数的用法时就已经研究清楚了

***

#### 函数实例可以作为函数的返回值进行返回

> 这个也容易理解，show这个函数的返回值就是函数类型。我们在函数show中定义了函数fu，然后在函数show的最后一行创建了一个函数fu的实例用于返回。因为函数show指定了返回值类型就是`String => Int` ，所以最后一行可以写成fu 而不是 fu _

``` scala
def show(): String => Int = {
    def fu(str : String)={
        1
    }
    fu
}

show()	// 调用show()返回的是函数fu的实例
show()("aa") // 这样返回的才是函数fu的返回值1 
```



### 函数闭包

> 以下代码定义了一个返回值类型为String => String的函数，并调用了这个函数。接下来对执行`func(2)("bighu")` 这行代码时jvm中发生的事进行分析，进而解释什么是闭包

> 假设一个scala程序中除了以下代码就只剩main方法了。main方法被调用，一个虚拟机被启动，此时在栈区中会生成一个虚拟机栈，然后main栈帧入栈。
>
> 当`def func()={}` 这块定义函数的代码被执行后，我猜测在方法区中会保存这个函数的定义代码。（就好像当我们创建一个类的对象时，类加载器将该类的字节码加载到方法区中。）但我不确定是在创建这个函数实例的时候将函数的定义代码加载到方法区还是在定义这个函数的时候就已经加载了。
>
> 当`func(2)("bighu")` 中的`func` 的等义代码`val f1 = func _`被执行时，执行引擎在堆中创建了一个func类型的实例，main栈帧中会有一个局部变量f1指向这个实例。
>
> 接着`val f2: String => String = f1(2)`被执行（也就是f1调用了一个方法，这个方法名或者函数名叫做func），对应的操作是func栈帧入栈，这个栈帧中包含局部变量age = 2，然后函数func2的定义语句被加载至方法区，然后在堆中创建了func2类型的实例，并将这个实例的地址返回给main栈帧中的局部变量f2，然后func栈帧出栈。
>
> 再接着`f2("bighu")` 被执行，也就是f2调用func2方法，func2栈帧入栈，局部变量有name。现在问题就来了，age这个局部变量从何而来？age这个局部变量在func栈帧出栈的时候就被释放了。所以说当f1调用方法func，返回一个func2类型的实例时，会把方法func中的局部变量一并存入这个func2的实例，所以当func2的实例调用方法func2时，会有age这个局部变量
>
> **总结：**闭包就是当调用一个函数得到一个返回值，这个返回值是一个函数类型的实例的时候，这个实例可以得到上一个函数所有的局部变量
>
> 所有函数类型的实例都是Function类的对象，不过Function类中会有东西来存这个函数类型的实例入参和返回值是什么类型，也会将这个函数体当作类的一个方法来保存。具体怎么实现的现在还比较疑惑，不过这解释了为什么一个函数实例可以调用方法，且这个方法就是这个函数本身

``` scala
def func(age: Int): String => String = {
    def func2(name : String):String = {
        name+"的年龄是"+age
    }

    func2
}

func(2)("bighu") // 返回值是"bighu的年龄是2"

// 以下代码是对func(2)("bighu")的拆分，底层执行逻辑一致，只是为了解释
val f1 = func _
val f2: String => String = f1(2)
f2("bighu") // 返回值是"bighu的年龄是2"
```



### 函数柯里化

> 当遇到以下类型的函数定义，可以将其柯里化。柯里化可以看作是将特殊的两层嵌套的函数定义为一个函数。

``` scala
def addByA(a:Int): Int=>Int ={
    def addB(b:Int):Int={
        a+b
    }

    addB
}
println(addByA(1)(2))

// 柯里化后

// 柯里化函数第一个小括号是最外层函数的形参列表，第二个小括号是内层函数的形参列表
// 柯里化函数是基于闭包原则的，执行柯里化函数的底层，我的理解是先创建外部函数的实例，并调用实例的方法返回一个内部函数实例，再调用内部函数实例的方法得到最终的返回值。执行原理和柯里化之前的函数一样。因为闭包原则，内部函数实例中保存了创建该内部函数实例的方法中的局部变量
def addCurrying(a:Int)(b:Int):Int={
    a+b
}
println(addCurrying(1)(2))
```



### 函数递归

> scala中的递归与java中的写法是一样的，但scala除了是面向对象编程外，也是函数式编程，函数式编程对递归都有优化。
>
> 当我们递归函数的最后一行只有调用自身时，这就是尾递归。对于尾递归，函数式编程语言会在你进入下一层调用时将上一层调用产生的栈帧出栈，避免栈资源的消耗

``` scala
// 尾递归代码
def f(i : Int,sum: Int): Int = {
    if(i<=1) return sum
    f(i-1,sum*(i-1))
}
```



### 控制抽象

> 一个函数可以接收各种数据类型的数据，包括Int类型、String类型，还有比较奇怪的函数类型的数据，还有代码块类型的数据
>
> 是的，scala的类型系统里可以再加个代码块类型了。函数类型可以用`String => Int` 来表示，代码块类型可以用`=> Int` 来表示，表示返回值类型为Int型的代码块

``` scala
// 这个函数的形参类型是返回值类型为String的代码块类型
// 局部变量a的值就是一个代码块
def f(a: => String): Unit = {
    println(a)
    a // 相当于调用了那个代码块，表达式a的返回值就是那个代码块的返回值
}

f({"这是一个代码块"}) //调用结果：控制台打印了"这是一个代码块"。这行代码的返回值为()，因为我们指定了函数f的返回值类型就是Unit，虽然函数f最后一行表达式的返回值类型是String，估计是使用了隐式转换将String类型转换成了Unit类型


// 定义函数f2
def f2(i : Int)={
    println(i)
    "s"
}

f(f2(1))
// 这里传入的f2(1)等同于以下代码块
{
    println(1)
    "s"
}
```



### 懒加载

> 使用懒加载可以在需要该资源的时候再去加载该资源，可以有效降低资源浪费

> 我们分析以下代码。经过debug分析，当运行完`lazy val re = sum(1,2)` 这行代码时，jvm中没有出现re这个常量，当执行第一个`println(re)` 语句时，sum函数被执行，re被初始化，然后再运行`println(re)` 将re的值打印。当调用第二个`println(re)`  语句时，就直接打印re的值，而没有重新调用sun函数
>
> 所以我推断，这段代码等价于将re的定义语句移到了第一次使用re的语句的上一句

```scala
def sum(a: Int, b: Int): Int = {
    println("sum调用")
    a + b
}

lazy val re = sum(1,2)

println("打印re")
println(re)

println("再次打印re")
println(re)
```

