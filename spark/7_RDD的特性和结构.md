### RDD的属性和特点

***

#### RDD的三大基本特性

##### 分区

> RDD是一个弹性分布式数据集，这个数据集会被分为若干个分区，不同的分区可以储存在不同节点上。
>
> 这些分区在物理上是以储存在内存或硬盘上的数据块的形式存在的
> 在编程过程中，我们创建的RDD对象内部存的并不是具体的数据，而是分区信息、血缘关系之类的
>
> 在集群中，各个节点上的数据块会尽可能的存在内存中，这样可以最大化大的减少磁盘IO

***

##### 不可变

> 每个RDD都是只读的，我们不能对它进行修改。所以我们要进行计算时，只能对原有的RDD进行一些操作，获得新的RDD。然后再操作，再获得新的RDD。直到我们拿到想要的结果。
>
> 这样的好处是当我们在 RDD 的计算过程中，不需要立刻去存储计算出的数据本身，我们只要记录每个 RDD 是经过哪些转化操作得来的，即：**依赖关系**，这样一方面可以提高计算效率，一方面是错误恢复会更加容易。如果在计算过程中，第 N 步输出的 RDD 的节点发生故障，数据丢失，那么可以根据依赖关系从第 N-1 步去重新计算出该 RDD，这也是 RDD 叫做**"弹性"**分布式数据集的一个原因。

***

##### 并行操作

> 因为 RDD 是分区的，且不同分区储存在不同节点上，所以RDD支持并行操作



#### RDD的内部结构

![image-20201202113839667](F:\学习笔记\spark\images\RDD的结构.png)

> 当我们在编程的过程中创建了一个RDD对象时，RDD对象里存的就是这些东西

##### Partitions

> partitions中储存了RDD的逻辑结构，并会指明哪个分区对应哪个节点的哪个数据块

***

##### SparkContext

> SparkContext可以看作是Spark的抽象，是所有 Spark 功能的入口，可以用来创建 RDD 对象以及在节点中的广播变量等等。

***

##### SparkConf

> SparkConf可以看作是spark中配置文件的抽象

***

##### Partitioner

> Partitioner 决定了 RDD 的分区方式，目前两种主流的分区方式：Hash partioner 和 Range partitioner。也可以由我们自定义partitioner

***

##### Dependencies

> dependencies是依赖关系，也可以叫做血缘关系，记录了当前这个RDD的计算过程。也就是说这个RDD是通过哪个RDD经过什么样的转化操作得到的
>
> **根据RDD的每个分区计算后生成新的RDD的分区的对应关系，可以分为宽依赖和窄依赖**
>
> 窄依赖就是父 RDD 的分区可以一一对应到子 RDD 的分区，宽依赖是说父 RDD 的每个分区可以被多个子 RDD 分区使用。
>
> 由于窄依赖的特性，窄依赖允许子 RDD 的每个分区可以被并行处理产生，而且支持在同一个节点上链式执行多条指令，无需等待其它父分区操作。宽依赖需要该子分区的所有父分区都是可用的。
>
> 从失败恢复的角度考虑，窄依赖失败恢复更有效，因为只要重新计算丢失的父分区即可，而宽依赖涉及到 RDD 的各级多个父分区。

![image-20201202135955305](F:\学习笔记\spark\images\窄依赖.png)

![image-20201202140021564](F:\学习笔记\spark\images\宽依赖.png)

***

##### Checkpoint

> 检查点机制，在计算过程中有一些比较耗时的 RDD，我们可以将它缓存到硬盘或者 HDFS 中，标记这个 RDD 有被检查点处理过，并且清空它的所有依赖关系。同时，给它新建一个依赖于 CheckpointRDD 的依赖关系，CheckpintRDD 可以用来从 硬盘中读取 RDD 和生成新的分区信息。
>
> 这么做之后，当某个 RDD 需要错误恢复时，回溯到该 RDD，发现它被检查点记录过，就可以直接去硬盘读取该 RDD，无需重新计算。

***

##### Preferred Location

> 针对每一个分片，都会选择一个最优的位置来计算，数据不动，代码动。

***

#### Storage Level

> 用来记录 RDD 持久化时存储的级别，常用的有：
>
> MEMORY_ONLY：只存在缓存中，如果内存不够，则不缓存剩余的部分。这是 RDD 默认的存储级别。
>
> MEMORY_AND_DISK：缓存在内存中，不够则缓存至内存。
>
> DISK_ONLY：只存硬盘。
>
> MEMORY_ONLY_2 和 MEMORY_AND_DISK_2等：与上面的级别和功能相同，只不过每个分区在集群两个节点上建立副本。

***

##### Iterator

> 迭代函数和计算函数是用来表示 RDD 怎样通过父 RDD 计算得到的。
>
> 迭代函数首先会判断缓存中是否有想要计算的 RDD，如果有就直接读取，如果没有就查找想要计算的 RDD 是否被检查点处理过。如果有，就直接读取，如果没有，就调用计算函数向上递归，查找父 RDD 进行计算。