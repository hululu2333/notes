### 时间复杂度

***

>  时间复杂度用来估算算法需要的运行时间 和 简化算法分析



#### 计算时间复杂度的前提

> 我们假设计算机运行一行基础代码需要执行一次运算。

```objectivec
int aFunc(void) {
    printf("Hello, World!\n");      //  需要执行 1 次
    return 0;       // 需要执行 1 次
}
```

> 那么上面这个方法需要执行 2 次运算

***

```objectivec
int aFunc(int n) {
    for(int i = 0; i<n; i++) {         // 需要执行 (n + 1) 次
        printf("Hello, World!\n");      // 需要执行 n 次
    }
    return 0;       // 需要执行 1 次
}
```

> 这个方法需要 (n + 1 + n  + 1) = 2n + 2 次运算。



#### 如何求时间复杂度

> 我们把 算法需要执行的运算次数 用 输入大小n 的函数 表示，即 T(n) 。
>
> 求时间复杂度的关键在于求出T(n)，然后根据某种规则将算法需要执行的运算次数T(n)根据某种规则转化为时间复杂度O(n)



#### T(n)转O(n)

> **去除常数项：**我们知道常数项对函数的增长速度影响并不大，所以当 T(n) = c，c 为一个常数的时候，我们说这个算法的时间复杂度为 O(1)；如果 T(n) 不等于一个常数项时，直接将常数项省略。

```undefined
第一个 Hello, World 的例子中 T(n) = 2，所以我们说那个函数(算法)的时间复杂度为 O(1)。
T(n) = n + 29，此时时间复杂度为 O(n)。
```

***

> **只保留高次项：**我们知道高次项对于函数的增长速度的影响是最大的。n^3 的增长速度是远超 n^2 的，同时 n^2 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。

```undefined
T(n) = n^3 + n^2 + 29，此时时间复杂度为 O(n^3)。
```

***

> **去除高次项的系数：**因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。

```undefined
T(n) = 3n^3，此时时间复杂度为 O(n^3)。
```

**综合起来：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。**



#### 求时间复杂度的简易方法

> 由上可知，由T(n)求到O(n)并不困难，但是T(n)有时候很难得到。所以有一些简便方法，让我们较为快速的得到一个算法的时间复杂度

***

> **求单层循环的时间复杂度：**对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n×m)。

```objectivec
void aFunc(int n) {
    for(int i = 0; i < n; i++) {         // 循环次数为 n
        printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
    }
}
```

> 此时时间复杂度为 O(n × 1)，即 O(n)。

***

> **求多层循环的时间复杂度：**假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c...，则这个循环的时间复杂度为 O(n×a×b×c...)。**分析的时候应该由里向外分析这些循环。**

```objectivec
void aFunc(int n) {
    for(int i = 0; i < n; i++) {         // 循环次数为 n
        for(int j = 0; j < n; j++) {       // 循环次数为 n
            printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
        }
    }
}
```

> 此时时间复杂度为 O(n × n × 1)，即 O(n^2)。

***

> **代码中有很多顺序执行片段时：**对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。

```objective
void aFunc(int n) {
    // 第一部分时间复杂度为 O(n^2)
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            printf("Hello, World!\n");
        }
    }
    // 第二部分时间复杂度为 O(n)
    for(int j = 0; j < n; j++) {
        printf("Hello, World!\n");
    }
}
```

> 此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。

***

> **遇见条件判断语句时：**对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。

```objective
void aFunc(int n) {
    if (n >= 0) {
        // 第一条路径时间复杂度为 O(n^2)
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                printf("输入数据大于等于零\n");
            }
        }
    } else {
        // 第二条路径时间复杂度为 O(n)
        for(int j = 0; j < n; j++) {
            printf("输入数据小于零\n");
        }
    }
}
```

> 此时时间复杂度为 max(O(n^2), O(n))，即 O(n^2)。

**时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。**