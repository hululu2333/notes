### JVM详解

***



#### JVM的作用

> 1. java代码通过IDE的编译生成字节码
> 2. 字节码被传输到JVM中
> 3. JVM将字节码逐行翻译成机器码，并交给cpu运行



#### JVM的生命周期

##### 诞生

>当启动一个java程序时，一个JVM实例就被创建了。
>
>也就是说，main方法被运行的时候，就是一个JVM实例诞生的时候。

***

##### 运行

> main()是该程序初始线程的起点，所有其他线程都由这个线程启动。
>
> main()是用户线程，守护线程一般是JVM自己在用，如垃圾回收机制。
>
> 我们创建的线程默认为用户线程，也可以指定其为守护线程。

***

##### 消亡

>当程序中所有的用户线程都终止了，这时JVM实例退出。
>
>因为守护线程是为用户线程服务的，当所有的用户线程都执行完毕，守护进程也就没有继续运行的必要了。这时JVM退出，导致所有守护进程都结束，也是没问题的。



#### JVM的组成部件

> JVM由三个部件组成，分别是类加载器(ClassLoader)、执行引擎和运行时数据区

***

##### 类加载器——用来加载.class文件

> **加载：**ClassLoader通过类名和类所在的包名找到字节码文件，并将字节码文件加载到JVM中

> **链接：**首先是对字节码的格式进行校验，初始化被加载的类中的静态变量并解析类中调用的接口、类
>
> 然后JVM初始化类中的静态变量，并将其赋为默认值
>
> 最后对类中所有的属性和方法进行验证，确保他们需要调用的属性和方法存在，并且有相应权限

> **初始化：**执行类中的静态初始化代码，构造器代码以及静态属性的初始化

> 在jvm中，被加载的类的唯一标识符是全限定名加类加载器的实例名
>
> 也就是说，一个全限定名相同的类，只会被同一个类加载器加载一次

***

##### 执行引擎——将字节码转换为机器码

> 执行技术主要分为解释、及时编译和自适应优化

***

##### 运行时数据区

> 方法区，堆，java栈，PC寄存器，本地方法栈，程序计数器



#### 类加载器

> 基本上所有的类加载器都是java.lang.ClassLoader的一个实例化对象

##### 双亲委派机制

> 当有一个类加载器在接到加载类的请求时，会将加载任务委托给父类加载器。父类加载器又委托给他的父类，以此类推。
>
> 如果父类加载器能完成加载，就成功返回。如果不能，就自己去加载

***

##### 引导类加载器

> 用来加载java的核心库，由原生代码实现，并不继承于java.lang.ClassLoader

***

##### 扩展类加载器

> 用来加载java的扩展库，java虚拟机被创建时会提供一个扩展库的目录。扩展类加载器会在目录中寻找并加载java类

***

##### 系统类加载器

> 它根据安装 Java 时配置的环境变量 CLASSPATH 来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader() 来获取它。

***

##### 自定义类加载器

> 通过继承java.lang.ClassLoader来实现自己的类加载器

<img src="F:\学习笔记\java\images\类加载器树.jpg" alt="类加载器树状组织结构示意图" style="zoom:80%;" />



#### 执行引擎

##### 一次性解释

> 将字节码转换为机器码，并送到cpu运行

***

##### 即时编译器

> 将字节码转换为机器码后，并将这些机器码保存在本地。
>
> 今后再遇到之前遇见过的字节码，就不转换，直接调用本地的机器码

***

##### 自适应优化器

> 统计各种字节码的使用频率，将使用频率最高的字节码的机器码保存下来



#### 运行时数据区

> JVM将它的内存分为几块不同的区域，用来储存程序运行时的一些数据

##### 程序计数器

> 每个线程都有自己独立的程序计数器，程序计数器用来记录字节码运行到哪一行了。
>
> 执行引擎就是根据程序计数器来决定运行哪一行字节码

***

##### 虚拟机栈

> 每个线程都对应着一个虚拟机栈，虚拟机栈描述的是java方法执行的内存模型
>
> 每有一个方法被执行，就有一个栈帧入栈。每个栈帧中都存着这个方法的局部变量、传入参数、操作数栈、动态链接、方法出口等消息
>
> 局部变量和传入参数的大小，还有操作数栈的深度在java代码编译的时候就已经确定，所以每个栈帧的大小是确定的

***

##### 本地方法栈

> 虚拟机栈是java方法执行的内存模型，而本地方法栈针对于本地方法的。
>
> 本地方法也就是native方法，是一个java接口，但这个接口是由非java代码实现的

***

##### 堆

> 一个jvm中只有一个堆，由所有线程共用。
>
> 堆中主要存放对象实例

***

##### 方法区

> 一个jvm中只有一个方法区，由所有线程共用
>
> ClassLoader将字节码加载到JVM中，就是存在方法区里。除此之外，方法区里还储存静态变量、即时编译器编译后的代码等数据。

***

##### 运行时常量池

> 属于方法区的一部分，用来存字符串常量等



#### 垃圾回收机制

> 垃圾回收针对的是堆和方法区
>
> 有两种确定垃圾的算法，分别是引用计数法和可达性分析
>
> 有四种回收算法，分别是标记清除算法、标记整理算法、复制算法以及分代回收算法