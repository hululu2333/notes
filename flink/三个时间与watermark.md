### 三种时间与watermark

***

#### 三种时间

> **Event-Time：**当数据源生产一个Event时，会在这个Event内部嵌入一个时间戳。这个时间戳就叫做事件时间，是这个Event产生的时间
>
> **Ingestion-Time：**摄取时间，也就是这个Event进入flink的时间
>
> **Processing-Time：**  处理时间，可以理解为对这个Event进行处理的时候的时间



#### watermark

> **时间窗口：**相比流处理和批处理，Flink采用了一种折中的方法，Flink以固定的缓存块为单位进行网络数据传输，用户可以通过缓存块超时值指定缓存块的传输时机。时间窗口的大小就是超时值，当时间窗口大小为0也就是超时值为0的时候，flink进行的就是纯实时计算
>
> 以下的消息等同于上文的Event

> 当操作符通过基于Event Time的时间窗口来处理数据时，它必须在确定所有属于该时间窗口的消息全部流入此操作符后才能开始数据处理。但是由于消息可能是乱序的，所以操作符无法直接确认何时所有属于该时间窗口的消息全部流入此操作符。
>
> 我们可以把watermark也看作是一个消息，这个消息中包含了一个特殊的时间戳，**Flink的数据源在确认所有小于某个时间戳的消息都已输出到Flink流处理系统后，会生成一个包含该时间戳的WaterMark，插入到消息流中输出到Flink流处理系统中。**
>
> Flink操作符按照时间窗口缓存所有流入的消息，当操作符处理到WaterMark时，它对所有小于该WaterMark时间戳的时间窗口数据进行处理并发送到下一个操作符节点，然后也将WaterMark发送到下一个操作符节点。
>
> 为了保证能够处理所有属于某个时间窗口的消息，操作符必须等到大于这个时间窗口的WaterMark之后才能开始对该时间窗口的消息进行处理，相对于基于Ingestion-Time的时间窗口，Flink需要占用更多内存，且会直接影响消息处理的延迟时间。对此，一个可能的优化措施是，对于聚合类的操作符，可以提前对部分消息进行聚合操作，当有属于该时间窗口的新消息流入时，基于之前的部分聚合结果继续计算，这样的话，只需缓存中间计算结果即可，无需缓存该时间窗口的所有消息。



三种时间参考：https://www.zhihu.com/search?type=content&q=flink%E6%97%B6%E9%97%B4

Watermark参考：https://www.jianshu.com/p/d5ccb3aaabc5